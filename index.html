<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src="acorn_interpreter.js"></script>
    <script src="blockly_compressed.js"></script>
    <script src="blocks_compressed.js"></script>
    <script src="python_compressed.js"></script>
    <script src="javascript_compressed.js"></script>
    <script src="msg/js/es.js"></script>
    <script src="wait_block.js"></script>
</head>

<body>
    Input
    <textarea id="input" name="FIELDNAME" style="height: 100px; width: 200px;"></textarea>
    Output
    <textarea id="output" style="height: 100px; width: 200px;"></textarea>
    <button id="execute" onclick="execute()">excecute</button>
    <div style="display: flex;">
        <div id="blocklyDiv" style="height: 480px; width: 600px;"></div>
        <div><textarea id="textarea" style="height: 480px; width: 200px;"></textarea></div>
    </div>
    <xml id="toolbox" style="display: none">
        <category name="Primitivas">
            <block type="text_print"></block>
        </category>
        <category name="Mis procedimientos" custom="PROCEDURE">
        </category>
        <category name="Repeticiones">
            <block type="controls_repeat_ext"></block>
            <block type="controls_whileUntil"></block>
        </category>
        <category name="Alternativas">
            <block type="controls_if"></block>
        </category>
        <category name="Valores">
            <block type="math_number"></block>
            <block type="text"></block>
        </category>
        <category name="Operadores">
            <block type="logic_compare"></block>
            <block type="math_arithmetic"></block>
        </category>
    </xml>
    <script>
        var workspace = Blockly.inject('blocklyDiv',
            {
                toolbox: document.getElementById('toolbox'),
                zoom:
                {
                    controls: true,
                    wheel: true,
                    startScale: 1.0,
                    maxScale: 3,
                    minScale: 0.3,
                    scaleSpeed: 1.2
                },
                trashcan: true,
                comments: false
            });


        // Exit is used to signal the end of a script.
        Blockly.JavaScript.addReservedWords('exit');
        function myUpdateFunction(event) {
            var code = Blockly.Python.workspaceToCode(workspace);
            document.getElementById('textarea').value = code;
            if (!(event instanceof Blockly.Events.Ui)) {
                // Something changed. Parser needs to be reloaded.
                resetInterpreter();
                generateCodeAndLoadIntoInterpreter();
            }
        }


        var outputArea = document.getElementById('output');
        var myInterpreter = null;
        var highlightPause = false;
        var runButton = document.getElementById('execute');
        var latestCode = '';
        var runner;
        function initApi(interpreter, globalObject) {
            // Add an API function for the alert() block, generated for "text_print" blocks.
            var wrapper = function (text) {
                text = text ? text.toString() : '';
                outputArea.value = outputArea.value + '\n' + text;
            };
            interpreter.setProperty(globalObject, 'alert',
                interpreter.createNativeFunction(wrapper));

            // Add an API function for the prompt() block.
            var wrapper = function (text) {
                text = text ? text.toString() : '';
                return interpreter.createPrimitive(prompt(text));
            };
            interpreter.setProperty(globalObject, 'prompt',
                interpreter.createNativeFunction(wrapper));

            // Add an API for the wait block.  See wait_block.js
            initInterpreterWaitForSeconds(interpreter, globalObject);

            // Add an API function for highlighting blocks.
            // Add an API function for highlighting blocks.
            var wrapper = function (id) {
                return workspace.highlightBlock(id);
            };
            interpreter.setProperty(globalObject, 'highlightBlock',
                interpreter.createNativeFunction(wrapper));

        }

        function highlightBlock(id) {
            workspace.highlightBlock(id);
            highlightPause = true;
        }


        function resetStepUi(clearOutput) {
            workspace.highlightBlock(null);
            highlightPause = false;
            runButton.disabled = '';
            if (clearOutput) {
                outputArea.value = '';
            }
        }

        function generateCodeAndLoadIntoInterpreter() {
            // Generate JavaScript code and parse it.
            Blockly.JavaScript.STATEMENT_PREFIX = 'highlightBlock(%1);\n';
            Blockly.JavaScript.addReservedWords('highlightBlock');
            //para highlightear la linea por la que va
            Blockly.JavaScript.addReservedWords('latestCode')
            //para no tener loops
            window.LoopTrap = 1000;
            Blockly.JavaScript.INFINITE_LOOP_TRAP = 'if(--window.LoopTrap == 0) throw "Infinite loop.";\n';
            latestCode = Blockly.JavaScript.workspaceToCode(workspace);
            resetStepUi(true);
        }

        function resetInterpreter() {
            myInterpreter = null;
            if (runner) {
                clearTimeout(runner);
                runner = null;
            }
        }

        function execute() {
            if (!myInterpreter) {
                // First statement of this code.
                // Clear the program output.
                resetStepUi(true);
                runButton.disabled = 'disabled';

                // And then show generated code in an alert.
                // In a timeout to allow the outputArea.value to reset first.
                setTimeout(function () {

                    // Begin execution
                    highlightPause = false;
                    myInterpreter = new Interpreter(latestCode, initApi);
                    runner = function () {
                        if (myInterpreter) {
                            var hasMore = myInterpreter.run();
                            if (hasMore) {
                                // Execution is currently blocked by some async call.
                                // Try again later.
                                setTimeout(runner, 10);
                            } else {
                                // Program is complete.
                                outputArea.value += '\n\n<< Program complete >>';
                                resetInterpreter();
                                resetStepUi(false);
                            }
                        }
                    };
                    runner();
                }, 1);
                return;
            }
        }
        // Load the interpreter now, and upon future changes.
        generateCodeAndLoadIntoInterpreter();
        workspace.addChangeListener(myUpdateFunction);
    </script>

</body>

</html>